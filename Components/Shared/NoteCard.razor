@using Timeline_Note_Taker.Models
@inject Timeline_Note_Taker.Services.LocalizationService Loc

<div class="note-card" data-type="@Note.Type.ToString().ToLower()">
    <div class="note-header">
        <div class="note-meta">
            <span class="note-time">@GetRelativeTime(Note.CreatedAt)</span>
            <span class="note-type-badge @Note.Type.ToString().ToLower()">@Note.Type</span>
        </div>
        <div class="note-actions">
            <button class="btn btn-icon btn-danger" @onclick="DeleteNote" title="@Loc["delete_tooltip"]">
                üóëÔ∏è
            </button>
        </div>
    </div>
    
    @if (!string.IsNullOrWhiteSpace(Note.Tags))
    {
        <div class="note-tags">
            @foreach (var tag in Note.Tags.Split(',', StringSplitOptions.RemoveEmptyEntries))
            {
                <span class="tag-badge">@tag.Trim()</span>
            }
        </div>
    }
    
    <div class="note-content @(Note.Type == NoteType.CodeSnippet ? "code-content" : "")">
        @((MarkupString)RenderContentWithImages(Note.Content))
    </div>
    
    @if (!string.IsNullOrEmpty(Note.Topic))
    {
        <div class="note-footer">
            <span class="note-topic">@Note.Topic</span>
        </div>
    }
</div>

@using Markdig

@code {
    [Parameter, EditorRequired]
    public Note Note { get; set; } = default!;

    [Parameter]
    public EventCallback OnDeleted { get; set; }
    
    // Cache the pipeline
    private static MarkdownPipeline? _pipeline;
    private static MarkdownPipeline Pipeline => _pipeline ??= new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .UseSoftlineBreakAsHardlineBreak()
        .Build();

    private string GetRelativeTime(DateTime dateTime)
    {
        // Show time for today, date+time for other days
        if (dateTime.Date == DateTime.Today)
            return dateTime.ToString("h:mm tt");
        
        return dateTime.ToString("MMM d, h:mm tt");
    }

    private async Task DeleteNote()
    {
        await OnDeleted.InvokeAsync();
    }
    
    // Parse Markdown and handle [Image: path] tags
    private string RenderContentWithImages(string content)
    {
        if (string.IsNullOrEmpty(content)) return string.Empty;
        
        // 1. Extract Images and replace with unique placeholders
        var imageMatches = System.Text.RegularExpressions.Regex.Matches(content, @"\[Image:\s*(.*?)\]");
        var imagePlaceholders = new Dictionary<string, string>();
        
        var processedContent = content;
        
        // We iterate in reverse or just replace one by one carefully. 
        // Unique placeholders using GUIDs to avoid Markdown collision
        int index = 0;
        foreach (System.Text.RegularExpressions.Match match in imageMatches)
        {
            var placeholder = $"__IMG_PLACEHOLDER_{Guid.NewGuid()}__";
            // Replace only the first occurrence of this specific match value to handle duplicates correctly if needed,
            // but Regex.Replace replaces all. Since fullTag is the specific string, safely replacing one by one or using index logic is better.
            // Let's use a simpler approach: Replace the exact string. If duplicates exist, they point to same image anyway.
            
            if (!imagePlaceholders.ContainsKey(match.Value))
            {
                imagePlaceholders[match.Value] = placeholder;
                processedContent = processedContent.Replace(match.Value, placeholder);
            }
        }
        
        // 2. Render Markdown
        // Note: Markdown encoding handles HTML safety
        string html = Markdown.ToHtml(processedContent, Pipeline);
        
        // 3. Restore Images (Injecting raw HTML)
        foreach (var kvp in imagePlaceholders)
        {
            var originalTag = kvp.Key; // [Image: path]
            var placeholder = kvp.Value;
            
            // Extract path again from original tag
            var match = System.Text.RegularExpressions.Regex.Match(originalTag, @"\[Image:\s*(.*?)\]");
            if (match.Success)
            {
                var imagePath = match.Groups[1].Value;
                string imgHtml;
                try 
                {
                    if (System.IO.File.Exists(imagePath))
                    {
                        var bytes = System.IO.File.ReadAllBytes(imagePath);
                        var base64 = Convert.ToBase64String(bytes);
                        imgHtml = $"<div class='note-image'><img src='data:image/png;base64,{base64}' alt='Attached Image' /></div>";
                    }
                    else
                    {
                        imgHtml = $"<div class='image-error'>Image not found: {Path.GetFileName(imagePath)}</div>";
                    }
                }
                catch
                {
                    imgHtml = $"<div class='image-error'>Error loading image</div>";
                }
                
                html = html.Replace(placeholder, imgHtml);
            }
        }
        
        return html;
    }
}
