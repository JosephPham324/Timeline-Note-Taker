@using Timeline_Note_Taker.Models
@inject Timeline_Note_Taker.Services.LocalizationService Loc

<div class="note-card" data-type="@Note.Type.ToString().ToLower()">
    <div class="note-header">
        <div class="note-meta">
            <span class="note-time">@GetRelativeTime(Note.CreatedAt)</span>
            <span class="note-type-badge @Note.Type.ToString().ToLower()">@Note.Type</span>
        </div>
        <div class="note-actions">
            <button class="btn btn-icon btn-danger" @onclick="DeleteNote" title="@Loc["delete_tooltip"]">
                üóëÔ∏è
            </button>
        </div>
    </div>
    
    @if (!string.IsNullOrWhiteSpace(Note.Tags))
    {
        <div class="note-tags">
            @foreach (var tag in Note.Tags.Split(',', StringSplitOptions.RemoveEmptyEntries))
            {
                <span class="tag-badge">@tag.Trim()</span>
            }
        </div>
    }
    
    <div class="note-content @(Note.Type == NoteType.CodeSnippet ? "code-content" : "")">
        @((MarkupString)RenderContentWithImages(Note.Content))
    </div>
    
    @if (!string.IsNullOrEmpty(Note.Topic))
    {
        <div class="note-footer">
            <span class="note-topic">@Note.Topic</span>
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public Note Note { get; set; } = default!;

    [Parameter]
    public EventCallback OnDeleted { get; set; }

    private string GetRelativeTime(DateTime dateTime)
    {
        // Show time for today, date+time for other days
        if (dateTime.Date == DateTime.Today)
            return dateTime.ToString("h:mm tt");
        
        return dateTime.ToString("MMM d, h:mm tt");
    }

    private async Task DeleteNote()
    {
        await OnDeleted.InvokeAsync();
    }
    
    // Parse [Image: path] tags and replace with actual img elements
    private string RenderContentWithImages(string content)
    {
        if (string.IsNullOrEmpty(content)) return string.Empty;
        
        // Basic HTML encoding for safety
        var safeContent = System.Net.WebUtility.HtmlEncode(content);
        
        // But we want to preserve newlines
        safeContent = safeContent.Replace("\n", "<br/>");
        
        // Regex to find [Image: path]
        // The path might contain spaces, so we capture everything until the closing bracket
        var matches = System.Text.RegularExpressions.Regex.Matches(content, @"\[Image:\s*(.*?)\]");
        
        if (matches.Count == 0) return safeContent;
        
        // We'll replace the encoded tags with proper HTML
        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            var fullTag = match.Value;
            var imagePath = match.Groups[1].Value;
            var encodedTag = System.Net.WebUtility.HtmlEncode(fullTag);
            
            try 
            {
                if (System.IO.File.Exists(imagePath))
                {
                    var bytes = System.IO.File.ReadAllBytes(imagePath);
                    var base64 = Convert.ToBase64String(bytes);
                    var imgHtml = $"<div class='note-image'><img src='data:image/png;base64,{base64}' alt='Attached Image' /></div>";
                    
                    safeContent = safeContent.Replace(encodedTag, imgHtml);
                }
                else
                {
                    safeContent = safeContent.Replace(encodedTag, $"<div class='image-error'>Image not found: {Path.GetFileName(imagePath)}</div>");
                }
            }
            catch
            {
                safeContent = safeContent.Replace(encodedTag, $"<div class='image-error'>Error loading image</div>");
            }
        }
        
        return safeContent;
    }
}
